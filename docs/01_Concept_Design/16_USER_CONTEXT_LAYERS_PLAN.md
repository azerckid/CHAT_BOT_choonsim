# 유저 컨텍스트 5계층 구현 계획서
> Created: 2026-02-08
> Last Updated: 2026-02-08

본 문서는 **USER_CONTEXT_LAYERS_SPEC**(`../03_Specs/21_user-context-layers-spec.md`)을 바탕으로 한 단계별 구현 계획이다. 명세서의 5계층(memory, heartbeat, identity, soul, tools), 스키마, API, 보안, 마이그레이션을 실제 작업 단위로 나누어 진행 순서와 검증 기준을 정의한다.

---

## 1. 개요

### 1.1 목적

- 명세서에 정의된 유저별 5계층 컨텍스트를 **단계적으로** 도입하여, 기존 채팅·AI 파이프라인에 부작용 없이 개인화 품질을 높인다.
- 각 단계별로 **완료 조건(검증)** 을 두어, 롤백 가능한 체크포인트를 확보한다.

### 1.2 참조 문서

| 문서 | 경로 | 용도 |
|------|------|------|
| 명세서 | `../03_Specs/21_user-context-layers-spec.md` | 요구사항, 스키마, API, 보안 정의 |
| DB 무결성 규칙 | AGENTS.md | 백업 후 마이그레이션 원칙 |
| 인터럽트 전략 | `../03_Specs/20_interrupt-strategy.md` | 채팅 파이프라인 연동 참고 |
| Phase 0 산출물 | `./17_USER_CONTEXT_LAYERS_PHASE0.md` | User.bio 사용처, 등급 위치, LangGraph 노드, 캐릭터 목록, bio 포맷 |

### 1.3 전제 조건

- [Safe Checkpoint] 구현 착수 전 현재 상태를 git commit 하거나 작업 디렉터리가 정리되어 있어야 한다.
- DB 스키마 변경·마이그레이션 전에는 [CRITICAL: DATABASE INTEGRITY RULE], [MANDATORY BACKUP PROCEDURE]에 따라 **전체 백업**을 선행한다.
- 기존 `User.bio` 사용 여부를 코드베이스에서 확인한 뒤, 마이그레이션 범위를 결정한다.

---

## 2. Phase 0: 사전 준비

### 2.1 목표

구현에 들어가기 전에 환경·데이터·의존성을 정리하고, 롤백 가능한 기준선을 만든다.

### 2.2 작업 항목

| 순서 | 작업 | 담당 | 산출물 |
|------|------|------|--------|
| 0.1 | Turso(또는 로컬 DB) **전체 덤프** 수행 | 백엔드 | 백업 파일 보관 확인 |
| 0.2 | `User` 테이블 및 `User.bio` 필드 사용처 코드 검색 | 백엔드 | 사용처 목록 문서 |
| 0.3 | 구독 등급(FREE/BASIC/PREMIUM/ULTIMATE) 정의 위치 확인 | 백엔드 | 등급 상수/테이블 참조 |
| 0.4 | LangGraph 대화 파이프라인 진입점·종료점 파악 | AI/백엔드 | 노드 목록, 호출 위치 |
| 0.5 | 구현 계획서 리뷰 및 Phase 1 착수 일정 확정 | 팀 | 일정 합의 |
| 0.6 | 캐릭터 목록 확정 | 기획/백엔드 | 캐릭터 ID 목록, 기본 캐릭터 정의 (`chunsim` 등) |
| 0.7 | 기존 메모리 포맷 분석 | 백엔드 | `User.bio` 현재 저장 형식, 파싱 규칙 문서화 |

### 2.3 완료 조건

- 백업 파일이 존재하며 복원 테스트가 가능함.
- `User.bio`를 읽거나 쓰는 코드 경로가 문서화됨.
- LangGraph에서 "대화 시작 시 로드" / "대화 종료 후 저장"을 끼워 넣을 노드(또는 훅) 후보가 식별됨.
- 지원할 캐릭터 목록이 확정되고, 기본 캐릭터 ID(`chunsim`)가 정의됨.
- 기존 `User.bio`의 저장 형식과 파싱 규칙이 문서화됨.

**Phase 0 산출물**: 위 항목의 조사 결과는 `./17_USER_CONTEXT_LAYERS_PHASE0.md`에 정리한다.

---

## 3. Phase 1: 스키마 및 기반 구축

### 3.1 목표

명세서 10절의 스키마와 타입을 DB에 반영하고, 컨텍스트를 다루는 최소한의 레이어(테이블·타입·관계)를 준비한다.

### 3.2 작업 항목

| 순서 | 작업 | 상세 | 산출물 |
|------|------|------|--------|
| 1.1 | Drizzle 스키마 추가 | `UserContext`, `UserMemoryItem` 테이블 정의 (명세 10.1, 10.2). `(userId, characterId)` 유니크/인덱스 반영 | `drizzle/schema.ts` (또는 `app/db/schema.ts`) 수정 |
| 1.2 | 마이그레이션 파일 생성 및 적용 | `drizzle-kit generate` 후 백업 확인 하에 `drizzle-kit push` 또는 migrate | 마이그레이션 파일, 적용 로그 |
| 1.3 | JSON 문서 타입 정의 | `HeartbeatDoc`, `IdentityDoc`, `SoulDoc`, `ToolsDoc` (명세 10.3) | `app/lib/context/types.ts` |
| 1.4 | 컨텍스트 조회/생성 헬퍼 | `(userId, characterId)` 기준 UserContext upsert, UserMemoryItem 목록 조회 (등급 무시, 단순 CRUD) | `app/lib/context/db.ts` 또는 유사 모듈 |
| 1.5 | 구독 등급 조회 유틸 | 유저의 현재 등급을 반환하는 함수 (기존 tier 테이블/필드 활용) | `app/lib/context/tier.ts` 등 |
| 1.6 | 캐릭터별 격리 검증 | `(userId, characterId)` 복합 키로 완전히 분리되는지, 다른 캐릭터 데이터 접근 불가 확인 | 테스트 코드 |
| 1.7 | 스키마 명세 대조 검증 | 생성된 스키마가 명세서 10.1, 10.2와 필드/타입/인덱스 일치 확인 | 검증 체크리스트 |

### 3.3 완료 조건

- `UserContext`, `UserMemoryItem` 테이블이 DB에 존재하고, Drizzle로 CRUD 가능함.
- 타입 정의가 명세 10.3과 일치하며, 기존 빌드/테스트가 깨지지 않음.
- `(userId, characterId)` 복합 키로 캐릭터별 데이터가 완전히 격리됨 (테스트 통과).
- 스키마가 명세서 10.1, 10.2와 필드/타입/인덱스 완전 일치 확인됨.
- **아직 채팅 플로우에는 미연동** (이 단계에서는 스키마와 내부 헬퍼만 준비).

---

## 4. Phase 2: Memory 계층 구현

### 4.1 목표

대화에서 "기억"을 추출해 저장하고, 프롬프트에 memory만 주입하여 연속성 효과를 검증한다.

### 4.2 작업 항목

| 순서 | 작업 | 상세 | 산출물 |
|------|------|------|--------|
| 2.0a | 등급별 한도 상수 정의 | `TIER_LIMITS` 상수 객체로 memory 개수 상한 정의: FREE=20, BASIC=50, PREMIUM=200, ULTIMATE=무제한 | `app/lib/context/constants.ts` |
| 2.0b | 한도 초과 정리 함수 | 상한 초과 시 오래된/낮은 중요도 항목 자동 정리 로직 (LRU + importance 기반) | `app/lib/context/memory.ts` |
| 2.1 | Memory 항목 추가 API (내부) | 최근 대화 텍스트를 입력받아 LLM으로 기억 후보 추출 → PII 필터(명세 7.2) 적용 → `UserMemoryItem` 삽입. 등급별 상한(FREE 20, BASIC 50 등) 적용, 초과 시 오래된/낮은 중요도 항목 정리 | `app/lib/context/memory.ts` |
| 2.2 | Memory 프롬프트 압축 | 토큰 예산(약 500) 내에서 최근/중요 항목 5~10개 선택해 문자열로 반환 (명세 12.1) | `app/lib/context/compress.ts` |
| 2.3 | LangGraph "대화 종료 후" 노드 연동 | 대화 종료 시 최근 N개 메시지를 memory 추출 함수에 전달, 실패 시 로그만 남기고 대화 플로우는 유지 | 그래프 노드 또는 훅 수정 |
| 2.4 | LangGraph "대화 시작 시" 노드 연동 | 해당 유저·캐릭터의 memory만 로드해 system(또는 state)에 주입. **기존 일반 채팅 경로는 조건 분기로 제외** | 그래프 노드 수정 |
| 2.5 | 단위/통합 테스트 | memory 추가·조회·한도 초과 시 정리 동작 검증 | 테스트 코드 |

### 4.3 완료 조건

- 대화 한 번 진행 후, 해당 유저·캐릭터에 memory 항목이 생성됨.
- 다음 대화에서 해당 memory가 프롬프트에 포함되어 응답에 반영됨.
- FREE 유저는 memory 20개 초과 시 오래된 항목이 정리됨.
- 비로그인/일반 채팅 플로우는 변경 없음 (영향 범위 격리).

---

## 5. Phase 3: Heartbeat 계층 구현

### 5.1 목표

접속·대화 시 last_seen, 빈도, 연속 접속일 등을 갱신하고, "오랜만/매일" 문맥을 프롬프트에 추가한다.

### 5.2 작업 항목

| 순서 | 작업 | 상세 | 산출물 |
|------|------|------|--------|
| 3.1 | Heartbeat 갱신 로직 | 대화 시작/종료 시 `lastSeenAt`, `recentDaysCount`, `streakDays` 등 계산해 `UserContext.heartbeatDoc` 업데이트. 등급에 따라 기본/상세 구분 (명세 4.3) | `app/lib/context/heartbeat.ts` |
| 3.2 | Heartbeat 프롬프트 압축 | 약 100 토큰 내 한 줄 요약 + 핵심 수치만 반환 | 기존 compress 또는 별도 함수 |
| 3.3 | LangGraph 연동 | "대화 시작 시" 노드에서 heartbeat 로드 후 system에 추가; "대화 종료 시" 노드에서 heartbeat 갱신 | 그래프 노드 |
| 3.4 | 테스트 | last_seen, streak, recentDaysCount 값이 기대대로 갱신되는지 검증 | 테스트 코드 |

### 5.3 완료 조건

- 대화 시 해당 유저·캐릭터의 heartbeat가 갱신됨.
- 프롬프트에 "오랜만이야" / "매일 와줘서 고마워" 등 리듬 기반 문맥이 반영됨.
- PREMIUM/ULTIMATE는 감정 추이 등 상세 필드가 채워짐 (구현 범위 내에서).

---

## 6. Phase 4: Identity 계층 구현

### 6.1 목표

닉네임, 호칭, 관계 유형을 저장하고, 프롬프트에 반영해 톤·호칭이 일관되게 유지된다.

### 6.2 작업 항목

| 순서 | 작업 | 상세 | 산출물 |
|------|------|------|--------|
| 4.1 | Identity 초기값 및 수정 | 유저가 설정한 닉네임·호칭·관계를 `identityDoc`에 저장. 기존 프로필 설정 UI가 있으면 해당 API에서 UserContext.identityDoc 갱신 | 설정 API 또는 전용 PUT |
| 4.2 | 대화에서 추론 (선택) | 대화 후 identity 추론 LLM 호출해 inferredTraits 등 보강. 우선순위는 유저 설정 > 추론 | `app/lib/context/identity.ts` |
| 4.3 | Identity 프롬프트 압축 | 약 100 토큰, nickname / honorific / relationshipType 위주 | compress |
| 4.4 | LangGraph 연동 | "대화 시작 시" 노드에서 identity 로드 후 system에 주입 | 그래프 노드 |
| 4.5 | 테스트 | 설정 변경 시 identity 반영, 프롬프트에 호칭/관계 포함 확인 | 테스트 코드 |

### 6.3 완료 조건

- 유저가 설정한 닉네임·호칭이 다음 대화부터 적용됨.
- AI 응답에서 호칭과 말투가 identity와 일치함.

---

## 7. Phase 5: Soul 계층 구현

### 7.1 목표

가치관, 소원, 고민 등 깊은 레이어를 저장하고, 깊은 대화 시 프롬프트에 soul 비중을 높여 주입한다.

### 7.2 작업 항목

| 순서 | 작업 | 상세 | 산출물 |
|------|------|------|--------|
| 5.1 | Soul 저장 로직 | PREMIUM/ULTIMATE만 soul 저장 허용 (명세 4.3). 대화 요약 또는 배치에서 가치/소원/고민 추출해 `soulDoc` 갱신 | `app/lib/context/soul.ts` |
| 5.2 | Soul 프롬프트 압축 | 약 300 토큰, 동적 토큰 할당(명세 12.2) 시 "깊은 대화"일 때 비중 확대 | compress |
| 5.3 | LangGraph 연동 | "대화 시작 시" soul 로드; "대화 종료 시" 또는 배치에서 soul 갱신 (memory보다 빈도 낮게) | 그래프/배치 |
| 5.4 | 등급 체크 | FREE/BASIC은 soul 미저장·미주입. 단, 읽기는 허용하되 내용이 빈 상태. 등급 업그레이드 시 soul 누적 시작 | tier 체크 |
| 5.5 | Soul 저장 빈도 정책 | Memory보다 낮은 빈도로 갱신 (예: 10회 대화당 1회, 또는 일 배치). 과도한 LLM 호출 방지 | 정책 설정·배치 코드 |

### 7.3 완료 조건

- PREMIUM/ULTIMATE 유저만 soul가 누적됨.
- 고민/위로가 필요한 대화에서 soul가 프롬프트에 포함되어 응답에 반영됨.

---

## 8. Phase 6: Tools 계층 구현

### 8.1 목표

피할 주제, 특별한 날(생일 등), 기능 온/오프 등 유저별 규칙을 저장하고, 시스템/에이전트가 참고하도록 한다.

### 8.2 작업 항목

| 순서 | 작업 | 상세 | 산출물 |
|------|------|------|--------|
| 6.1 | Tools CRUD | `toolsDoc` 읽기/쓰기. 유저 설정 화면 또는 관리자 도구에서 설정 | `app/lib/context/tools.ts` |
| 6.2 | Tools 프롬프트 압축 | 약 100 토큰, 활성 규칙·specialDates 위주 | compress |
| 6.3 | LangGraph/시스템 연동 | "대화 시작 시" tools 로드 후 system에 주입; 특별한 날 판별 시 specialDates 참고 | 그래프 노드 |
| 6.4 | 테스트 | avoidTopics, specialDates가 응답/동작에 반영되는지 검증 | 테스트 코드 |

### 8.3 완료 조건

- 유저가 "피할 주제" 또는 "생일"을 설정하면 다음 대화부터 반영됨.
- 관리자(또는 정책)에 의한 규칙 설정이 가능함.

---

## 9. Phase 7: API 엔드포인트 및 삭제·export

### 9.1 목표

명세 11절의 REST API를 구현하고, 삭제·export를 통해 감사·디버깅·정책 준수를 지원한다.

### 9.2 작업 항목

| 순서 | 작업 | 상세 | 산출물 |
|------|------|------|--------|
| 7.1 | GET `/api/context/:characterId` | 5계층 전체 조회 (memory는 count 또는 요약). 세션 인증, 본인만 허용 | 라우트·핸들러 |
| 7.2 | PUT identity / tools | 본인 수정용 PUT. Zod 스키마로 검증 | 라우트·핸들러 |
| 7.3 | GET/POST/DELETE memory | 목록 조회, 시스템용 추가, 본인 항목 삭제 | 라우트·핸들러 |
| 7.4 | DELETE `/api/context/:characterId` | 캐릭터 컨텍스트 전체 삭제. "복구 불가" 확인 절차 (명세 7.1) | 라우트·핸들러 |
| 7.5 | POST export | 5계층을 .md 형태로 응답 (또는 파일 다운로드). 본인만 | 라우트·핸들러 |
| 7.6 | 감사 로그 | 삭제 요청 시각·범위 기록; 관리자 조회 시 로그 (원문 미포함) | 로그 모듈 |
| 7.7 | PUT `/api/context/:characterId/heartbeat` | heartbeat 갱신 (명세 11.1). 대화 시작/종료 시 내부 함수로 호출하거나 REST로 트리거 | 라우트·핸들러 |
| 7.8 | PUT `/api/context/:characterId/soul` | soul 갱신 (명세 11.1). 배치 또는 대화 후 추론 시 호출. PREMIUM/ULTIMATE만 저장 | 라우트·핸들러 |
| 7.9 | GET `/api/context/all` | 본인의 모든 캐릭터 컨텍스트 목록 조회. 캐릭터별 요약 정보 반환 | 라우트·핸들러 |

### 9.3 완료 조건

- 명세 11.1의 엔드포인트가 모두 동작하며, 권한(본인/시스템/관리자)이 명세와 일치함.
- 시스템 API (heartbeat, soul 갱신)가 내부적으로 호출 가능함.
- 모든 캐릭터 컨텍스트 목록 조회 API가 동작함.
- 삭제 시 확인 절차와 감사 로그가 적용됨.
- export 호출 시 5계층이 읽기 쉬운 형태로 반환됨.

---

## 10. Phase 8: 보안 및 PII·접근 제어

### 10.1 목표

명세 7절(삭제, PII 필터, 접근 권한·감사)을 코드로 구현하여 개인정보보호 및 규정 대응을 완료한다.

### 10.2 작업 항목

| 순서 | 작업 | 상세 | 산출물 |
|------|------|------|--------|
| 8.1 | PII 필터 (명세 7.2) | memory 저장 직전 정규식으로 카드/주민/전화/계좌 등 탐지 → 마스킹 또는 저장 제외. 필요 시 LLM 2차 검토 | `app/lib/context/pii-filter.ts` |
| 8.2 | 삭제 정책 구현 (명세 7.1) | 전체 기억 삭제 / 캐릭터별 삭제 / 항목 삭제 / 계정 탈퇴 시 5계층 삭제 플로우. 복구 불가 안내 문구 통일 | 삭제 API·탈퇴 플로우 |
| 8.2a | 전체 기억 삭제 | 해당 유저의 모든 캐릭터·모든 계층 삭제. 2단계 확인 필수 (모달 + 재입력) | DELETE `/api/context` |
| 8.2b | 캐릭터별 삭제 | 특정 캐릭터의 5계층만 삭제. 다른 캐릭터 데이터는 유지 | DELETE `/api/context/:characterId` |
| 8.2c | 항목 삭제 | 특정 memory 항목만 삭제. 가장 낮은 위험도 | DELETE `/api/context/:characterId/memory/:itemId` |
| 8.2d | 계정 탈퇴 연동 | 탈퇴 플로우에서 5계층 삭제 자동 호출. 탈퇴 전 export 권유 | 탈퇴 API 연동 |
| 8.3 | 접근 권한 (명세 7.3) | 모든 컨텍스트 API에 세션 인증; 타인 데이터 접근 시 403. ADMIN만 타인 조회 가능, 조회 시 감사 로그 | 미들웨어·라우트 |
| 8.4 | 로그 검토 | 5계층 원문이 로그에 남지 않도록 점검 | 로그 정책 문서·코드 리뷰 |

### 10.3 완료 조건

- memory에 카드번호 등이 원문 그대로 저장되지 않음 (또는 마스킹됨).
- 4가지 삭제 유형(전체/캐릭터별/항목/계정 탈퇴)이 명세 표와 동일하게 동작함.
- 전체 삭제 시 2단계 확인(모달 + 재입력)이 적용됨.
- 계정 탈퇴 시 5계층 삭제가 자동 연동되며, 탈퇴 전 export 권유가 표시됨.
- 타인 컨텍스트 조회는 ADMIN만 가능하며, 조회 시 감사 로그가 남음.

---

## 11. Phase 9: 기존 데이터 마이그레이션 (User.bio → 5계층)

### 11.1 목표

명세 9절에 따라 기존 `User.bio` 기반 memory를 새 테이블로 이전하고, 병행·전환·롤백을 안전하게 수행한다.

### 11.2 작업 항목

| 순서 | 작업 | 상세 | 산출물 |
|------|------|------|--------|
| 9.1 | 마이그레이션 스크립트 작성 | `User.bio`에서 memory 추출 → 캐릭터별 기본(예: chunsim)으로 `UserContext`/`UserMemoryItem` 생성. id 생성 규칙, characterId 기본값 정의 | `scripts/migrate-user-bio-to-context.mjs` 등 |
| 9.2 | 1차 마이그레이션 실행 | 백업 후 스크립트 실행. 이전 건수·실패 건수 로그 | 실행 로그 |
| 9.3 | 정합성 검증 | 샘플 유저에 대해 bio memory와 새 테이블 내용 대조 | 검증 리포트 |
| 9.4 | 듀얼 라이트 (선택) | 일정 기간 동시에 bio와 새 테이블에 쓰기, 동기화 검증 | 코드·설정 |
| 9.5 | 읽기 전환 | 채팅/LangGraph에서 bio 대신 새 테이블만 참조하도록 전환 | 코드 수정 |
| 9.6 | User.bio deprecate | memory 관련 쓰기 제거, 주석 또는 deprecation 표시 | 코드·문서 |
| 9.7 | 롤백 스크립트 준비 | 새 테이블 → bio 역이전 스크립트 (필요 시 사용) | `scripts/rollback-context-to-bio.mjs` |

### 11.3 완료 조건

- 기존 memory를 가진 유저가 새 테이블 기준으로 동일한 기억을 사용함.
- 읽기 전환 후 채팅 품질이 이전과 동등 이상임.
- 문제 발생 시 롤백 스크립트로 복귀 가능함.

---

## 12. Phase 10: 토큰 예산 및 LangGraph 통합 정리

### 12.1 목표

명세 12절의 토큰 예산과 동적 할당을 일원화하고, LangGraph 플로우를 문서화하여 유지보수성을 높인다.

### 12.2 작업 항목

| 순서 | 작업 | 상세 | 산출물 |
|------|------|------|--------|
| 10.0a | 대화 유형 분류기 | 대화 맥락에서 유형 판별: 첫 대화 / 깊은 대화 / 일상 대화 / 특별한 날. LLM 또는 규칙 기반 | `app/lib/context/conversation-classifier.ts` |
| 10.0b | 동적 토큰 할당 매트릭스 | 대화 유형별 계층 비중 정의: 첫 대화(identity↑), 깊은 대화(soul↑), 일상(memory↑), 특별한 날(tools↑) | `app/lib/context/token-budget.ts` |
| 10.1 | 토큰 예산 모듈 | 계층별 상한·우선순위·압축 전략을 한 곳에서 관리. 대화 유형(첫 대화/깊은 대화/일상/특별한 날)에 따른 동적 할당 (명세 12.2) | `app/lib/context/token-budget.ts` |
| 10.2 | 5계층 로드 노드 고정 | "대화 시작 시" 한 번에 5계층 로드 → 예산에 맞게 압축 → system 주입. 다이어그램(명세 12.3)과 코드 일치 확인 | LangGraph 노드·문서 |
| 10.3 | 컨텍스트 갱신 노드 고정 | "대화 종료 시" memory/heartbeat(및 필요 시 identity/soul) 갱신. 실패 시 대화는 성공으로 두고 로그만 | LangGraph 노드·문서 |
| 10.4 | 기능 문서 업데이트 | `docs/03_Specs/` 또는 AI 파이프라인 문서에 "5계층 주입 위치", "토큰 예산 정책" 요약 추가 | 문서 |

### 12.3 완료 조건

- 대화 유형 분류기가 첫 대화/깊은 대화/일상/특별한 날을 구분함.
- 대화 유형에 따라 계층별 토큰 비중이 동적으로 조절됨.
- 토큰 사용량이 계층별 상한을 넘지 않으며, 상황별로 비중 조절이 적용됨.
- LangGraph 다이어그램과 실제 노드 구성이 일치함.
- 신규 참여자가 문서만으로 5계층 연동 위치를 파악할 수 있음.

---

## 13. 일정·마일스톤 (참고)

아래는 예시이며, 팀 리소스에 맞게 조정한다. 추가된 작업 항목을 반영하여 조정됨.

| Phase | 내용 | 예상 기간 (참고) | 비고 |
|-------|------|-------------------|------|
| 0 | 사전 준비 | 2~3일 | 캐릭터 목록, 메모리 포맷 분석 추가 |
| 1 | 스키마 및 기반 | 3~4일 | 격리 검증, 스키마 대조 추가 |
| 2 | Memory | 4~5일 | 한도 상수 정의, 정리 함수 추가 |
| 3 | Heartbeat | 2~3일 | - |
| 4 | Identity | 2~3일 | - |
| 5 | Soul | 3~4일 | 저장 빈도 정책, 배치 코드 추가 |
| 6 | Tools | 2~3일 | - |
| 7 | API·삭제·export | 3~4일 | 시스템 API 3개 추가 |
| 8 | 보안·PII·접근 제어 | 3~4일 | 삭제 유형별 상세 구현 추가 |
| 9 | User.bio 마이그레이션 | 3~4일 | 병행 기간 별도 |
| 10 | 토큰 예산·문서 정리 | 2~3일 | 대화 분류기, 동적 할당 매트릭스 추가 |
| - | 테스트 (통합) | 3~5일 | 단위·통합·성능 테스트 |

**마일스톤**

- **M1 (Phase 2 완료)**: Memory만으로 "기억하는 춘심" 체감 가능. 여기서 품질 검증 후 다음 계층으로 진행 권장.
- **M2 (Phase 7 완료)**: 유저/관리자가 API로 5계층 조회·수정·삭제·export 가능.
- **M3 (Phase 9 완료)**: 기존 유저 데이터가 새 구조로 완전 이전, User.bio 의존 제거.

---

## 14. 리스크 및 롤백

| 리스크 | 대응 |
|--------|------|
| LangGraph 연동 시 기존 채팅 깨짐 | 조건 분기로 "5계층 사용 여부" 플래그 두고, 플래그 꺼지면 기존과 동일 경로만 사용. 단계별 기능 플래그 권장. |
| LLM 추출(memory/soul) 실패·지연 | 추출 실패 시 해당 대화만 memory 미반영, 채팅 자체는 성공 처리. 타임아웃 설정. |
| 마이그레이션 중 데이터 불일치 | Phase 9 전에 백업 필수. 병행 기간에 양쪽 데이터 비교 검증. 롤백 스크립트 사전 테스트. |
| 등급별 한도 버그 | tier 조회를 단일 모듈로 두고, 모든 계층에서 동일 함수 사용. 단위 테스트로 한도 경계 검증. |

**공통 롤백 원칙**

- Phase 단위로 기능 플래그 또는 브랜치로 되돌릴 수 있게 유지.
- DB 변경은 반드시 백업 후 적용하며, 필요 시 마이그레이션 down 또는 수동 복구 절차를 문서화.

---

## 15. 테스트 전략

### 15.1 단위 테스트

| 대상 | 테스트 내용 | 우선순위 |
|------|------------|----------|
| PII 필터 | 카드번호, 주민번호, 전화번호, 계좌번호 마스킹 검증 | 높음 |
| 등급별 한도 | FREE/BASIC/PREMIUM/ULTIMATE 각 한도 경계값 검증 | 높음 |
| 토큰 압축 | 계층별 토큰 상한 준수 여부 | 중간 |
| 캐릭터 격리 | `(userId, characterId)` 조합별 데이터 분리 검증 | 높음 |

### 15.2 통합 테스트

| 시나리오 | 검증 내용 |
|----------|----------|
| 대화 흐름 E2E | 대화 시작 → 컨텍스트 로드 → 응답 → 컨텍스트 갱신 |
| 등급 업그레이드 | FREE→PREMIUM 전환 시 soul 저장 활성화 |
| 마이그레이션 | User.bio → 새 테이블 이전 후 동일 기억 사용 |
| 삭제 플로우 | 각 삭제 유형별 정상 동작 및 복구 불가 확인 |

### 15.3 성능 테스트

- 컨텍스트 로드 시간: 대화 시작 시 500ms 이내
- 컨텍스트 갱신 시간: 대화 종료 후 1초 이내 (비동기 허용)
- 토큰 예산 계산: 100ms 이내

---

## 16. 문서 이력

| 날짜 | 변경 내용 |
|------|-----------|
| (작성일) | 명세서 기반 구현 계획서 초안 작성 |
| 2026-02-05 | 명세서 업데이트 반영: Phase 0 캐릭터/메모리 분석 추가, Phase 1 격리 검증 추가, Phase 2 한도 상수 상세화, Phase 5 저장 빈도 정책 추가, Phase 7 시스템 API 3개 추가, Phase 8 삭제 유형 상세화, Phase 10 동적 할당 분류기 추가, 테스트 전략 섹션 신설 |
| 2026-02-05 | Phase 10 구현 완료: 대화 유형 분류기(conversation-classifier), 토큰 예산 모듈(token-budget), 채팅 라우트 동적 예산 적용, 계층별 maxTokens 지원, context-integration-summary.md 추가 |

이 계획서는 `../03_Specs/21_user-context-layers-spec.md`가 수정될 경우, 해당 변경을 반영해 갱신한다.

---

**작성일**: 2026-02-05


## Related Documents
- **Foundation**: [Document Management Plan](./08_DOCUMENT_MANAGEMENT_PLAN.md) - 문서 관리 규칙 및 구조
